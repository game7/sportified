module Typescript::Models
  class Generator
    class << self
      include Associations
      include BaseTypes
      include Conversions
      include Projections

      def generate
        load_application!
        types = []
        types.concat(generate_models)
        types.concat(generate_projections)
        File.open(output_file_path, 'w') { |file| file.write(output(types)) }
      end

      def auto_generate
        listener = Listen.to(Rails.root.join('app/models'), only: /.rb$/) do |_modified, _added, _removed|
          # Rails.logger.info "File(s) Changed (#{modified}) -- updating typescript models"
          generate_models
        end
        listener.start
      end

      def output_file_path
        Rails.root.join('app/javascript/models.d.ts')
      end

      def load_application!
        Rails.application.eager_load!
      end

      def generate_models
        models.collect do |model|
          begin
            properties = build_columns(model) + build_associations(model)
          rescue StandardError => e
            # puts "Typescript::Models - Unable to produce types for #{model_name(model)} - #{e}"
            properties = []
          end

          {
            name: model_name(model),
            properties: properties
          }
        end
      end

      def models
        ActiveRecord::Base.descendants.reject(&:abstract_class?).sort_by(&:name)
      end

      private

      def models_file_header
        [
          '// DO NOT MODIFY',
          '//',
          '// This file was automatically generated by Typescript.generate_models.  Please do not attempt to resolve',
          '// merge conflicts manually but instead run `rails ts:generate_models` after resolving all conflicts within',
          '// model files',
          '//',
          '/* eslint-disable @typescript-eslint/no-unused-vars, @typescript-eslint/no-explicit-any */'
        ]
      end

      def output(types)
        out = models_file_header
        out.concat(base_types)
        types.each do |type|
          out.concat(build_type(type))
        end
        out << ''
        out.join("\n")
      end

      # build type definition for the specified model class/type, wrapping within
      # module/namespace blocks and indenting each level by 2 spaces
      def build_type(type)
        path = type[:name].split('.')
        name = path.pop
        indent = path.length * 2
        out = []
        out.concat namespace_start(path)
        out << "interface #{name} {".indent(indent)
        out.concat properties(type, indent + 2)
        out << '}'.indent(indent)
        out.concat namespace_end(path)
        out
      end

      def namespace_start(path)
        path.map.with_index { |part, index| "namespace #{part} {".indent(index * 2) }
      end

      def namespace_end(path)
        path.map.with_index { |_part, index| '}'.indent((path.length - index - 1) * 2) }
      end

      # produce output strings for all properties
      def properties(type, indent)
        type[:properties].map { |prop| property(prop).indent(indent) }
      end

      # produce output string for a property
      def property(prop)
        "#{prop[:name]}: #{prop[:ts_type]};"
      end

      # extract attribute metadata from model
      def build_columns(model)
        types = {}

        model.columns.each do |col|
          type = conversions[col.type.to_s] || 'unknown'

          if (enum = model.defined_enums[col.name])
            type = enum.keys.map { |key| "'#{key}'" }.join(' | ')
          end

          types[col.name] = {
            type: type,
            nullable: col.null
          }
        end

        model.attribute_names.collect do |name|
          klass_name = model.attribute_types[name].class.to_s

          types[name] = {
            type: attribute_conversions[klass_name] || "unknown /* #{klass_name} */",
            nullable: types.key?(name) ? types[name][:nullable] : true
          }
        end

        types.entries.map do |key, value|
          { name: key, ts_type: value[:nullable] ? "#{value[:type]} | null" : value[:type] }
        end
      end

      # extract the model name from the model class, appending the namespace "App"
      # if the model does not exist within a ruby module
      def model_name(model_class)
        parts = model_class.name.camelize.split('::')
        parts.unshift('App') if parts.length == 1
        parts.join('.')
      end
    end
  end
end
