module Typescript::Models
  class Generator
    class << self
      include Associations
      include BaseTypes
      include Conversions

      def generate
        types = []
        models.each do |model|
          types << {
            name: model_name(model),
            properties: build_attributes(model) + build_associations(model)
          }
        rescue StandardError => e
          puts "Typescript::Models - Unable to produce types for #{model_name(model)} - #{e}"
        end
        File.open(output_file_path, 'w') { |file| file.write(output(types)) }
      end

      def auto_generate
        listener = Listen.to(Rails.root.join('app/models'), only: /.rb$/) do |_modified, _added, _removed|
          # Rails.logger.info "File(s) Changed (#{modified}) -- updating typescript models"
          generate_models
        end
        listener.start
      end

      def output_file_path
        Rails.root.join('app/javascript/models.d.ts')
      end

      def models
        Rails.application.eager_load!
        ActiveRecord::Base.descendants.reject(&:abstract_class?).sort_by(&:name)
      end

      private

      def models_file_header
        [
          '// DO NOT MODIFY',
          '//',
          '// This file was automatically generated by Typescript.generate_models.  Please do not attempt to resolve',
          '// merge conflicts manually but instead run `rails ts:generate_models` after resolving all conflicts within',
          '// model files',
          '//',
          '/* eslint-disable @typescript-eslint/no-unused-vars, @typescript-eslint/no-explicit-any */'
        ]
      end

      def output(types)
        out = models_file_header
        out.concat(base_types)
        types.each do |type|
          out.concat(build_type(type))
        end
        out << ''
        out.join("\n")
      end

      # build type definition for the specified model class/type, wrapping within
      # module/namespace blocks and indenting each level by 2 spaces
      def build_type(type)
        path = type[:name].split('.')
        name = path.pop
        indent = path.length * 2
        out = []
        out.concat namespace_start(path)
        out << "interface #{name} {".indent(indent)
        out.concat properties(type, indent + 2)
        out << '}'.indent(indent)
        out.concat namespace_end(path)
        out
      end

      def namespace_start(path)
        path.map.with_index { |part, index| "namespace #{part} {".indent(index * 2) }
      end

      def namespace_end(path)
        path.map.with_index { |_part, index| '}'.indent((path.length - index - 1) * 2) }
      end

      # produce output strings for all properties
      def properties(type, indent)
        type[:properties].map { |prop| property(prop).indent(indent) }
      end

      # produce output string for a property
      def property(prop)
        "#{prop[:name]}: #{prop[:ts_type]};"
      end

      # extract attribute metadata from model
      def build_attributes(model)
        model.columns.map do |i|
          type = conversions[i.type.to_s]
          if (enum = model.defined_enums[i.name])
            type = enum.keys.map { |k| "'#{k}'" }.join(' | ')
          end

          {
            name: i.name,
            ts_type: i.null ? "#{type} | null" : type
          }
        end
      end

      # extract the model name from the model class, appending the namespace "App"
      # if the model does not exist within a ruby module
      def model_name(model_class)
        parts = model_class.name.camelize.split('::')
        parts.unshift('App') if parts.length == 1
        parts.join('.')
      end
    end
  end
end
